// Copyright (c) 2024 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: jms-intro
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2024-08-29
:page-description: Learn how to produce and consume messages in Java microservices by using Jakarta Messaging with Liberty Messaging Server, Liberty Messaging Server Client, and IBM MQ.
:page-tags: ['jakarta-ee']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-related-guides: ['jakarta-websocket']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:source-highlighter: prettify
:page-seo-title: Producing and consuming messages in Java microservices by using Jakarta Messaging
:page-seo-description: A getting started tutorial with examples on how to produce and consume messages in Java microservices by using Jakarta Messaging with Liberty Messaging Server, Liberty Messaging Server Client, and IBM MQ.
= Producing and consuming messages in Java microservices


[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to produce and consume messages in Java microservices by using Jakarta Messaging with Liberty Messaging Server, Liberty Messaging Server Client, and IBM MQ.

== What you'll learn
You will learn how to communicate Java services by using Jakarta Messaging with Liberty Messaging Server, Liberty Messaging Server Client, and IBM MQ. You will use a Jakarta Messaging system to handle the asynchronous messages that are sent and received between the microservices as streams of events.

You'll also explore the configuration and use of Liberty Messaging Server, along with examples of message production and consumption with Liberty Messaging Server Client. Additionally, you will discover how to integrate Liberty Messaging Server with IBM MQ.

In this guide, you will use Jakarta Messaging APIs to build the application and implement a messaging solution that enables communication between different parts of Java microservices. Jakarta Messaging makes it easy to write and configure your application to send, receive, and process the events efficiently.

*What is Jakarta Messaging?*

Jakarta Messaging provides an easy way to asynchronously send, receive, and process messages that are received as continuous streams of events. By integrating Jakarta Messaging with Open Liberty, you can easily configure and manage message producers and consumers within your Java microservices. You simply use the Jakarta Messaging API to annotate methods in your application beans, and Open Liberty handles the communication infrastructure, ensuring messages are reliably exchanged. This integration allows your services to connect easily with external messaging systems, such as IBM MQ.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system` microservice calculates and publishes an event that contains its current average system load. The `inventory` microservice subscribes to that information so that it can keep an updated list of all the systems and their current system loads. The current inventory of systems can be accessed via the `/systems` REST endpoint. You'll create the `system` and `inventory` microservices using Java Message System.

image::architecture.png[Application architecture where system and inventory services use the Jakarta Messaging to communicate.,align="center"]

== Additional prerequisites
If youâ€™re focusing on sections other than *Using IBM MQ*, you can move forward without running Docker and skip this part.

IBM MQ container is required to run if you are using Linux.

Before you begin, you need to install Docker if it is not already installed. For installation instructions, refer to the https://docs.docker.com/get-docker/[official Docker documentation^]. You will build and run the application in Docker containers.

Make sure to start your Docker daemon before you proceed.
// =================================================================================================
// Getting started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]
// =================================================================================================
// Try what you'll build
// =================================================================================================

=== Try what you'll build

The `finish` directory in the root of this guide contains the finished application. Give it a try before you proceed.

To try out the application, first go to the `finish` directory and run the following Maven goal to build and install the `models` module.
```
cd finish
mvn -pl models clean install
```

Start the `inventory` service by running the following command:
```
mvn -pl inventory liberty:run
```

Next, open another command-line session, navigate to the `finish` directory, and start the `system` service by using the following command:
```
mvn -pl system liberty:run
```

After you see the following message, your Liberty instances are ready:
[role="no_copy"]
----
The defaultServer server is ready to run a smarter planet.
----

Visit the http://localhost:9085/health[^] URL to confirm that the `inventory` microservice is up and running.

When both the liveness and readiness health checks are up, go to the http://localhost:9085/inventory/systems[^] URL to access the `inventory` microservice. You see the CPU systemLoad property for all the systems:

[source, role='no_copy']
----
{
   "hostname": <your hostname>,
   "systemLoad": 2.25927734375
}
----

You can revisit the http://localhost:9085/inventory/systems[^] URL after a while, and you will notice the CPU `systemLoad` property for the systems changed.

You can also use `curl` command to retrieve the hostname and systemLoad information from the `inventory/systems` server endpoint in another command line session:
```
curl http://localhost:9085/inventory/systems
```

After you are finished checking out the application, stop the Liberty instance by pressing `CTRL+C` in each command-line sessions where you ran Liberty. Alternatively, you can run the `liberty:stop` goal from the `finish` directory in another shell session:
// stopping dev mode
[role='command']
----
mvn -pl inventory liberty:stop
mvn -pl system liberty:stop
----

== Creating the message producer in the system service 

Navigate to the `start` directory to begin.

The `system` microservice is the producer of the messages that are published to the Jakarta messaging system as a stream of events. Every 15 seconds, the `system` microservice publishes an event that contains its calculation of the average system load (its CPU usage) for the last minute.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `SystemService` class.#
`system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

The `SystemService` class contains a `Publisher` method that is called [hotspot=sendSystemLoad file=0]`sendSystemLoad()`, which calculates and returns the average system load. The [hotspot=createProducer file=0]`context.createProducer().send()` method publishes its calculation as a message on a topic in the Jakarta messaging system. The [hotspot=schedule file=0]`@Schedule` annotation on the [hotspot=sendSystemLoad file=0]`sendSystemLoad()` method is used to set the frequency of how often the system service publishes the calculation to the event stream.

The messages are transported between the service and the messaging system through a queue called `systemLoad`. The [hotspot=schedule file=0]`@Schedule` annotation ensures the [hotspot=sendSystemLoad file=0]`sendSystemLoad()` method runs every 15 seconds.
This method creates new SystemLoad object with the hostname and system load average, then sends this information to the specified queue using [hotspot=createProducer file=0]`context.createProducer().send()` method.

// update server.xml
[role='code_command hotspot file=1', subs="quotes"]
----
#Replace the system's `server.xml` configuration file.#
`system/src/main/liberty/config/server.xml`
----

system/server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/liberty/config/server.xml[]
----

Add the [hotspot=jms file=1]`jms` feature to the Liberty `server.xml` configuration file. This feature enables applications running on Liberty to provide Jakarta Messaging services. Add a [hotspot=connectionManager file=1]`connection manager` to handles connections for the inventory system. Then, configure a [hotspot=jmsQueueConnectionFactory file=1]`JMSQueueConnectionFactory` to use this connection manager and set its properties. Lastly, define a [hotspot=jmsQueue file=1]`JMS Queue` for the inventory system.

If you want to learn more about configuration for the `jmsQueue` element and `jmsQueueConnectionFactory` element, see the https://openliberty.io/docs/latest/reference/config/jmsQueue.html[jmsQueue Server Properties^] and https://openliberty.io/docs/latest/reference/config/jmsQueueConnectionFactory.html[jmsQueueConnectionFactory Server Properties^].


== Creating the consumer in the inventory microservice

Navigate to the `start` directory to begin.
ifdef::cloud-hosted[]
```bash
cd /home/project/guide-jms-intro/start
```
endif::[]

When you run Open Liberty in https://openliberty.io/docs/latest/development-mode.html[dev mode^], dev mode listens for file changes and automatically recompiles and deploys your updates whenever you save a new change. Run the following goal to start Open Liberty in dev mode:

//start dev mode
[role='command']
----
mvn -pl inventory liberty:dev
mvn -pl system liberty:dev
----
After you see the following message, your Liberty instance is ready in dev mode:

[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

The `inventory` microservice records in its inventory the average system load information that it received from potentially multiple instances of the `system` service.

// Create and explain InventoryQueueListener class
[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `InventoryQueueListener` class.#
`inventory/src/main/java/io/openliberty/guides/inventory/InventoryQueueListener.java`
----

InventoryQueueListener.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryQueueListener.java[]
----


* replace the server.xml and explain the JMS configration

// =================================================================================================
// Running the application
// =================================================================================================

[role='command']
include::{common-includes}/devmode-build.adoc[]

You can find the `inventory` and `system` services at the following URLs:

* http://localhost:9080/inventory/systems[http://localhost:9080/inventory/systems^]

== Testing the inventory application

* similar to https://openliberty.io/guides/cdi-intro.html#testing-the-inventory-application
* explain the test

=== Running the tests

* similar to https://openliberty.io/guides/cdi-intro.html#running-the-tests
* stop the dev mode of the system and inventory services

== Using IBM MQ - Optional

* start IBM MQ on Linux
* replace the server.xml of the system and inventory services
* start dev mode for the system and inventory services
* run the url
* run test on inventory dev mode
* tear down to stop IBM MQ and dev mode
