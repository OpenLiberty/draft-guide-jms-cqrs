// Copyright (c) 2024 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: jms-intro
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2024-08-29
:page-description: Learn how to produce and consume messages in Java microservices by using Jakarta Messaging with Liberty Messaging Server, Liberty Messaging Server Client, and IBM MQ.
:page-tags: ['jakartaee']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-related-guides: ['jakarta-websocket']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:source-highlighter: prettify
:page-seo-title: Producing and consuming messages in Java microservices by using Jakarta Messaging
:page-seo-description: A getting started tutorial with examples on how to produce and consume messages in Java microservices by using Jakarta Messaging with Liberty Messaging Server, Liberty Messaging Server Client, and IBM MQ.
= Producing and consuming messages in Java microservices


[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to produce and consume messages in Java microservices by using Jakarta Messaging with Liberty Messaging Server, Liberty Messaging Server Client, and IBM MQ.

== What you'll learn
You will learn how to produce and consume messages in Java microservices using Jakarta Messaging.

You'll also explore the configuration and use of Liberty Messaging Server, along with examples of message production and consumption with Liberty Messaging Server Client. Additionally, you will discover how to integrate Liberty Messaging Server with IBM MQ.

Open Liberty, which supports Jakarta Messaging API, will be used to demonstrate how to build scalable messaging solutions. By the end of this tutorial, you will have implemented real-world messaging solutions to enhance the reliability and responsiveness of your Java microservices.

*What is Java Message Service (JMS) ?*

Java Message Service (JMS) is a Java API that enables applications to create, send, receive, and read messages asynchronously. It supports two messaging models: Point-to-Point (Queue), where messages are sent to a specific queue and consumed by a single receiver, and Publish/Subscribe (Topic), where messages are broadcast to a topic and received by multiple subscribers. JMS ensures reliable messaging with mechanisms for acknowledgment and redelivery in case of failures, using providers like IBM MQ.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system` microservice calculates and publishes an event that contains its current average system load. The `inventory` microservice subscribes to that information so that it can keep an updated list of all the systems and their current system loads. The current inventory of systems can be accessed via the `/systems` REST endpoint. You'll create the `system` and `inventory` microservices using Java Message System.

image::architecture.png[Application architecture where system and inventory services use the Jakarta Messaging to communicate.,align="center"]


== Additional prerequisites

Before you begin, you need to install Docker if it is not already installed. For installation instructions, refer to the https://docs.docker.com/get-docker/[official Docker documentation^]. You will build and run the application in Docker containers.

Make sure to start your Docker daemon before you proceed.

// =================================================================================================
// Getting started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]

=== Try what you'll build

Polish the following instruction.

Navigate to the finish directory.
```
cd finish
```

Build and install the models
```
mvn -pl models clean install
```

Start `inventory` service in dev mode:
```
mvn -pl inventory liberty:run
```

Start `system` service in dev mode:
```
mvn -pl system liberty:run
```

Visit http://localhost:9085/health or try out http://localhost:9085/inventory/systems

Get
```
curl http://localhost:9085/inventory/systems
```

== Creating the message producer in the system service 

- start the dev mode
- create and explain SystemService class
- replace the server.xml and explain the JMS configration

== Creating the consumer in the inventory microservice

- start the dev mode
- Create and explain InventoryQueueListener class
- replace the server.xml and explain the JMS configration

== Running the application

- similar to the https://openliberty.io/guides/cdi-intro.html#running-the-application

== Testing the inventory application

- similar to https://openliberty.io/guides/cdi-intro.html#testing-the-inventory-application
- explain the test

=== Running the tests

- similar to https://openliberty.io/guides/cdi-intro.html#running-the-tests
- stop the dev mode of the system and inventory services

== Using IBM MQ - Optional

- start IBM MQ on Linux
- replace the server.xml of the system and inventory services
- start dev mode for the system and inventory services
- run the url
- run test on inventory dev mode
- tear down to stop IBM MQ and dev mode
